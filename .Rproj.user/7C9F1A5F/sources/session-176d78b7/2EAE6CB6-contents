##Antnumspeed
#A comparison of the mean trajectory speed with the number of ants in the frame

#dat is data; by default it is indexed as (time in frames) x (trajectory #) x (x vec/y vec/heading/magnitude of motion)
#outbound is how the analysis is restricted; 0 = all trajectories, 1 = outbound only, 2 = inbound only
#rm0 is whether to remove trajectories with a median speed of 0 (typically dead ants or other inconsequential objects); 1 removes, 0 keeps
#mintime and maxtime restrict the time (mintime is 1 by default for indexing purposes)
#binno (bin number) is the number of colors used to code for relative numbers on the trail
#legloc (legend location) takes values 1-4, starting in the upper left and going clockwise
#keepscale is whether the axes should be scaled to the data in the restricted time (FALSE) or the data as a whole (TRUE)

Antnumspeed <- function(dat = trajs, outbound = 0, rm0 = 1,
                       mintime = 0, maxtime,
                       binno = 6, legloc = 1, keepscale = FALSE,
                       titles = 'Relationship of # of ants on trail to mean'){
  Antnumspeed.f(dat, outbound, rm0, mintime, maxtime, binno, legloc, keepscale, titles)
}

Antnumspeed.f <- function(trajs.antnumspeed, outbound.antnumspeed = 1, rm0.antnumspeed,
                         mintime.antnumspeed, maxtime.antnumspeed,
                         binno.antnumspeed, legloc.antnumspeed, keepscale.antnumspeed,
                         titles.antnumspeed){
  
  #Greatest number of trajectories in region during any frame (for purposes of coloring)
  antmax.antnumspeed <- max(rowSums(!is.na(trajs.antnumspeed[,,4])))             
  
  #Removing trajectories with a median speed of 0
  if(rm0.antnumspeed == 1){
    trajsm <- colMedians(trajs.antnumspeed[,,4], na.rm = TRUE)
    trajs.antnumspeed <- trajs.antnumspeed[,!trajsm == 0,]
  }
  
  #Converting mintime input arguments to frames, then setting min frame to 1 if it is 0 to avoid indexing problems below
  mintimef.antnumspeed <- mintime.antnumspeed*300
  if(mintimef.antnumspeed == 0){
    mintimef.antnumspeed <- 1
  }
  
  #Ending frame found if not given as an argument
  if(missing(maxtime.antnumspeed)){
    maxtimef.antnumspeed <- dim(trajs.antnumspeed)[1]
  }else{
    maxtimef.antnumspeed <- maxtime.antnumspeed*300                                #Converting argument from minutes to frames
  }
  
  #Assembles the main title of the plot based on input arguments
  plotitle <- paste0(titles.antnumspeed,
    if(outbound.antnumspeed==1){
      ' outbound'
    }else if(outbound.antnumspeed==2){
      ' inbound'
    }else{
      ' inbound and outbound'
    },
      ' trajectory speed (', mintime.antnumspeed, 'm to ', round(maxtimef.antnumspeed/300),'m)',
   if(rm0.antnumspeed==1){
      ', zeros removed'
    }else{
      ', zeros not removed'
    }
  )
  
  #Getting X and Y values for plot
  eks <- rowSums(!is.na(trajs.antnumspeed[mintimef.antnumspeed:maxtimef.antnumspeed,,4]))
  wye <- rowMeans(trajs.antnumspeed[mintimef.antnumspeed:maxtimef.antnumspeed,,4], na.rm = TRUE)
  
  #if/else statement for Outbound argument
  if(outbound.antnumspeed == 1){
    wye <- wye[colSums(trajs.antnumspeed[,,1], na.rm = TRUE) < 1]
  }else if(outbound.antnumspeed == 2){
    wye <- wye[colSums(trajs.antnumspeed[,,1], na.rm = TRUE) > 1]
  }
  
  #Plotting function with KEEPSCALE option
  if(keepscale.antnumspeed == FALSE){
    plot(x = eks, y = wye,
         main = plotitle, xlab = '# of ants on trail', ylab = ' mean speed of ants on trail (cm/s)',
         col = floor( (rowSums(!is.na(trajs.antnumspeed[mintimef.antnumspeed:maxtimef.antnumspeed,,4]))/antmax.antnumspeed*binno.antnumspeed)+1 ))
  }else{
    wyekeep <- rowMeans(trajs.antnumspeed[,,4], na.rm = TRUE)
    plot(x = eks, y = wye,
         main = plotitle, xlab = '# of ants on trail', ylab = ' mean speed of ants on trail (cm/s)',
         xlim = c(0,antmax.antnumspeed), ylim = c(min(wyekeep, na.rm = TRUE), max(wyekeep, na.rm = TRUE)),
         col = floor( (rowSums(!is.na(trajs.antnumspeed[mintimef.antnumspeed:maxtimef.antnumspeed,,4]))/antmax.antnumspeed*binno.antnumspeed)+1 ))
  }
  
  
  
  #dims.antnumspeed <- c(par("usr"), par("usr")[3]+(par("usr")[4]-par("usr")[3])/60, par("usr")[3]+2*((par("usr")[4]-par("usr")[3])/60)) #Values for time lines below; dims.antnumspeed[1:4] are size of the plot, dims.antnumspeed[5] is calculating where to put the text just above the bottom of the frame, dims.antnumspeed[6] is where the dotted line ends just above the text
  
  #Add mean line of entire time series (not just selected time)
  abline(mean(trajs.antnumspeed[,,4], na.rm = TRUE), 0, lty = 5)
  
  #Add trend line (of only selected time)
  abline(lm(wye~eks), lty = 3)
  
  #Add legend
  if(legloc.antnumspeed == 1){
    legend("topleft", inset = 0.03, title = "Ants in region",
           legend=c(paste("0 to", floor(antmax.antnumspeed/binno.antnumspeed)),paste(floor(antmax.antnumspeed/binno.antnumspeed*((2:binno.antnumspeed)-1))+1, "to", floor(antmax.antnumspeed/binno.antnumspeed*(2:binno.antnumspeed)))),
           fill = 1:binno.antnumspeed)
  }else if(legloc.antnumspeed == 2){
    legend("topright", inset = 0.03, title = "Ants in region",
           legend=c(paste("0 to", floor(antmax.antnumspeed/binno.antnumspeed)),paste(floor(antmax.antnumspeed/binno.antnumspeed*((2:binno.antnumspeed)-1))+1, "to", floor(antmax.antnumspeed/binno.antnumspeed*(2:binno.antnumspeed)))),
           fill = 1:binno.antnumspeed)
  }else if(legloc.antnumspeed == 3){
    legend("bottomright", inset = 0.03, title = "Ants in region",
           legend=c(paste("0 to", floor(antmax.antnumspeed/binno.antnumspeed)),paste(floor(antmax.antnumspeed/binno.antnumspeed*((2:binno.antnumspeed)-1))+1, "to", floor(antmax.antnumspeed/binno.antnumspeed*(2:binno.antnumspeed)))),
           fill = 1:binno.antnumspeed)
  }else if(legloc.antnumspeed == 4){
    legend("bottomleft", inset = 0.03, title = "Ants in region",
           legend=c(paste("0 to", floor(antmax.antnumspeed/binno.antnumspeed)),paste(floor(antmax.antnumspeed/binno.antnumspeed*((2:binno.antnumspeed)-1))+1, "to", floor(antmax.antnumspeed/binno.antnumspeed*(2:binno.antnumspeed)))),
           fill = 1:binno.antnumspeed)
  }else{
    #print("No legend added; choose 1-4 for topleft, topright, bottomright, or bottomleft.")
  }
}



Antnumspeed.mass <- function(dat = trajs, outbound = 0, rm0 = 1,
                             mintime = 0, maxtime, winsize = 10,
                             xdim, ydim,
                             binno = 6, legloc = 1, keepscale = TRUE){
  
  #Ending frame found if not given as an argument
  if(missing(maxtime)){
    maxtime <- floor(dim(dat)[1]/300)
  }
  
  #Getting how many graphs to be produced then converting it to a vector for the loop
  graphno <- floor((maxtime - mintime) / winsize)
  graphnoi <- seq(from = mintime, by = winsize, length.out = graphno)
  
  #Getting xdim and ydim if not supplied and setting up graph grid (need to refine so it does better than a square always)
  if(missing(xdim)){
    xdim <- ceiling(sqrt(graphno))
  }
  
  if(missing(ydim)){
    ydim <- ceiling(sqrt(graphno))
  }
  
  nf <- par()
  par(mfrow = c(ydim,xdim))
  
  #Loop that populates the graph grid
  for(i in graphnoi){
    #if(i > (xdim * ydim)){break}                                          #stops loop if it goes beyond the designated grid size
    
    Antnumspeed(dat = dat, outbound = outbound, rm0 = rm0, 
            mintime = i, maxtime = i + winsize,
            binno = binno, legloc = legloc, keepscale = keepscale)
    
  }
  
  par(mfrow = c(1,1)) #return to default 1x1 graph
  
}


