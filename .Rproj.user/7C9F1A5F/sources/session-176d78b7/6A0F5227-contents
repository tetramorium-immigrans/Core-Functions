#NET DIRECTION OF X-MOVEMENT
#dat is the data (the file name without suffix; must begin with a letter)
#winspace and winsize are the "window spacing" and "window size" for averaging function in seconds
#mintime and maxtime are the start and end times for the graph in minutes 
#binno is the "bin number" for how many categories for coloring purposes
#lspace is the "line spacing" for graphical purposes in minutes
#legloc is the "legend location" (1 = topleft, 2 = topright, 3 = bottomright, 4 = bottomleft, any other number for no legend)
#keepscale is whether to scale the y-axis to the whole data set or just the selected region


#Wrapper function for Antnetx.f
Antnetx <- function(dat = trajs, winspace = 20, winsize = 20, 
                    mintime = 0, maxtime,
                    binno = 6, lspace = 10, legloc = 1, keepscale = FALSE){
  Antnetx.f(dat,winspace,winsize,mintime,maxtime,binno,lspace,legloc,keepscale)
}


Antnetx.f <- function(trajs.antnetx, winspace.antnetx, winsize.antnetx, 
                      mintime.antnetx, maxtime.antnetx, 
                      binno.antnetx, lspace.antnetx, legloc.antnetx, keepscale.antnetx){
  
  
  #Greatest number of trajectories in region during any frame (for coloring purposes)
  antmax.antnetx <- max(rowSums(!is.na(trajs.antnetx[,,1])))
  
  #Ending frame found if not given as an argument
  if(missing(maxtime.antnetx)){
    maxtimef.antnetx <- dim(trajs.antnetx)[1]
  }else{
    maxtimef.antnetx <- maxtime.antnetx*300                                #Converting argument from minutes to frames
  }
  
  #Converting input arguments to frames
  winspacef.antnetx <- winspace.antnetx*5
  winsizef.antnetx <- round(winsize.antnetx * 5 / 2)                       #Halved since the value will be used to extend to either side of a point
  mintimef.antnetx <- mintime.antnetx*300
  lspacef.antnetx <- lspace.antnetx*300
  
  
  #Main plotting function
  if(keepscale.antnetx == TRUE){                                          #If keeping the scale, find out the appropriate scale for the full data set then plot
    rsums <- rowSums(trajs.antnetx[,,1], na.rm = TRUE)
    plot(x = mintimef.antnetx:maxtimef.antnetx, y = rsums[mintimef.antnetx:maxtimef.antnetx], 
         ylim = c(min(rsums), max(rsums)),
         main = paste0("Net x-movement of ants (mean window size ", winsize.antnetx, "s every ", winspace.antnetx, "s)"), xlab = "Frame Number", ylab = "Sum of the x-component of velocities (cm/sec)", 
         col = floor( (rowSums(!is.na(trajs.antnetx[mintimef.antnetx:maxtimef.antnetx,,1]))/antmax.antnetx*binno.antnetx)+1 ))
    dims.antnetx <- c(par("usr"), par("usr")[3]+(par("usr")[4]-par("usr")[3])/60, par("usr")[3]+2*((par("usr")[4]-par("usr")[3])/60)) #Values for time lines below; dims[1:4] are size of the plot, dims[5] is calculating where to put the text just above the bottom of the frame, dims[6] is where the dotted line ends just above the text
    
  }else{
    plot(x = mintimef.antnetx:maxtimef.antnetx, y = rowSums(trajs.antnetx[mintimef.antnetx:maxtimef.antnetx,,1], na.rm = TRUE)[1:length(mintimef.antnetx:maxtimef.antnetx)], 
         main = paste0("Net x-movement of ants (mean window size ", winsize.antnetx, "s every ", winspace.antnetx, "s)"), xlab = "Frame Number", ylab = "Sum of the x-component of velocities (cm/sec)", 
         col = floor( (rowSums(!is.na(trajs.antnetx[mintimef.antnetx:maxtimef.antnetx,,1]))/antmax.antnetx*binno.antnetx)+1 ))
    dims.antnetx <- c(par("usr"), par("usr")[3]+(par("usr")[4]-par("usr")[3])/60, par("usr")[3]+2*((par("usr")[4]-par("usr")[3])/60)) #Values for time lines below; dims[1:4] are size of the plot, dims[5] is calculating where to put the text just above the bottom of the frame, dims[6] is where the dotted line ends just above the text
  }
  
  
  #Add x-axis, mean line, and arrows to indicate direction of bait and nest
  lines(c(dims.antnetx[1],maxtimef.antnetx), c(0,0), type = "l", lty = 3)                                    #draw x-axis
  
  meanline <- mean(rowSums(trajs.antnetx[mintimef.antnetx:maxtimef.antnetx,,1], na.rm = TRUE), na.rm = TRUE) #get the mean line value
  lines(c(dims.antnetx[1],maxtimef.antnetx), c(meanline, meanline), type = "l", lty = 3)                     #draw the mean line
  
  arrows(x0 = rep(dims.antnetx[1]+(par("usr")[2]-par("usr")[1])/60, 2), y0 = c((par("usr")[4]-par("usr")[3])/60, (par("usr")[3]-par("usr")[4])/60), y1 = c((par("usr")[4]-par("usr")[3])/12, (par("usr")[3]-par("usr")[4])/12), length = 0.2)
  text(x = rep(dims.antnetx[1]+(par("usr")[2]-par("usr")[1])/60, 2), y = c((par("usr")[4]-par("usr")[3])/9, (par("usr")[3]-par("usr")[4])/9), labels = c("Nest", "Bait"), srt = 90)
  
  
  #Code for placing average points and lines; if/else if/else for when the window would go below 0, above maxtimef, or otherwise is in the middle respectively
  for(i in seq(from = mintimef.antnetx, to = maxtimef.antnetx, by = winspacef.antnetx)){       
    if((i - winsizef.antnetx) < 1){
      points(x = i, y = mean(rowSums(trajs.antnetx[(1):(i+winsizef.antnetx),,1], na.rm = TRUE)), pch = 18, col = "gray26")
      if(i != 0){ #if statement to avoid erroring on first segment with a 0 index
        segments(i - winspacef.antnetx, mean(rowSums(trajs.antnetx[(1):(i-winspacef.antnetx+winsizef.antnetx),,1], na.rm = TRUE)), 
                 i, mean(rowSums(trajs.antnetx[(1):(i+winsizef.antnetx),,1], na.rm = TRUE)), col = "gray26")
      }
    }else if((i + winsizef.antnetx) > maxtimef.antnetx){
      points(x = i, y = mean(rowSums(trajs.antnetx[(i-winsizef.antnetx):(maxtimef.antnetx),,1], na.rm = TRUE)), pch = 18, col = "gray26")
      segments(i - winspacef.antnetx, mean(rowSums(trajs.antnetx[(i-winspacef.antnetx-winsizef.antnetx):(maxtimef.antnetx),,1], na.rm = TRUE)), 
               i, mean(rowSums(trajs.antnetx[(i-winsizef.antnetx):(maxtimef.antnetx),,1], na.rm = TRUE)), col = "gray26")
    }else{
      points(x = i, y = mean(rowSums(trajs.antnetx[(i-winsizef.antnetx):(i+winsizef.antnetx),,1], na.rm = TRUE)), pch = 18, col = "gray26")
      if((i-winspacef.antnetx-winsizef.antnetx) > 0){ #if statement to avoid erroring on segments outside the index
        segments(i - winspacef.antnetx, mean(rowSums(trajs.antnetx[(i-winspacef.antnetx-winsizef.antnetx):(i-winspacef.antnetx+winsizef.antnetx),,1], na.rm = TRUE)), 
                 i, mean(rowSums(trajs.antnetx[(i-winsizef.antnetx):(i+winsizef.antnetx),,1], na.rm = TRUE)), col = "gray26")
      }
    }
  }
  
  #Add and label dotted lines for time
  for(i in seq(from = 0, to = maxtimef.antnetx, by = lspacef.antnetx)){      
    lines(c(i,i), c(dims.antnetx[4],dims.antnetx[6]), type = "l", lty = 3, lwd = 0.5, col = rgb(0,0,0, alpha = 0.25))
    text(i, dims.antnetx[5], labels = paste0(i / 300, "m"), col = rgb(0,0,0, alpha = 0.45))
  }
  
  #Add legend
  if(legloc.antnetx == 1){
    legend("topleft", inset = 0.03, title = "Ants in region",
           legend=c(paste("0 to", floor(antmax.antnetx/binno.antnetx)),paste(floor(antmax.antnetx/binno.antnetx*((2:binno.antnetx)-1))+1, "to", floor(antmax.antnetx/binno.antnetx*(2:binno.antnetx)))),
           fill = 1:binno.antnetx)
  }else if(legloc.antnetx == 2){
    legend("topright", inset = 0.03, title = "Ants in region",
           legend=c(paste("0 to", floor(antmax.antnetx/binno.antnetx)),paste(floor(antmax.antnetx/binno.antnetx*((2:binno.antnetx)-1))+1, "to", floor(antmax.antnetx/binno.antnetx*(2:binno.antnetx)))),
           fill = 1:binno.antnetx)
  }else if(legloc.antnetx == 3){
    legend("bottomright", inset = 0.03, title = "Ants in region",
           legend=c(paste("0 to", floor(antmax.antnetx/binno.antnetx)),paste(floor(antmax.antnetx/binno.antnetx*((2:binno.antnetx)-1))+1, "to", floor(antmax.antnetx/binno.antnetx*(2:binno.antnetx)))),
           fill = 1:binno.antnetx)
  }else if(legloc.antnetx == 4){
    legend("bottomleft", inset = 0.03, title = "Ants in region",
           legend=c(paste("0 to", floor(antmax.antnetx/binno.antnetx)),paste(floor(antmax.antnetx/binno.antnetx*((2:binno.antnetx)-1))+1, "to", floor(antmax.antnetx/binno.antnetx*(2:binno.antnetx)))),
           fill = 1:binno.antnetx)
  }else{
    print("No legend added; choose 1-4 for topleft, topright, bottomright, or bottomleft.")
  }
  
}